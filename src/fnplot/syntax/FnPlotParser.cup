package fnplot.syntax;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import fnplot.sys.SyntaxFnPlotException;
import fnplot.values.FnPlotValue;
import fnplot.values.FnPlotReal;
import fnplot.syntax.inbuiltfunctions.*;


/* Preliminaries to set up and use the scanner.  */
parser code {:
		FnPlotLexer lexer;

		public FnPlotParser(FnPlotLexer l) {
		    // As of CUP v0.11, need to pass Lexer to superclass
		    super(l);
		    lexer = l;
		}

		public void report_error(String message, Object info) {
		    System.err.println(message);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
				     " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error", cur_token);
		    System.err.println ("Last token read is " +
					 lexer.getText());
		}
	    :};

init with {:
	  :};

scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
                    String msg = "Line " + lexer.getLine() + ", pos " +
				       lexer.getColumn() +
				       ": Unrecognised token <" +
				       lexer.getText() + ">";
		    throw new SyntaxFnPlotException(msg, ioe);
		}
	  :};

/* Terminals (tokens returned by the scanner). */

// special symbols
terminal LPAREN, RPAREN;

//Britt Bratt 
terminal DEF;
terminal IF, THEN, ELSE;
terminal AND, OR, NOT;
terminal READ, READINT;
non terminal ExpConcat CONCAT; 
non terminal concat;
non terminal StmtSequence helper;
/*non terminal comp;*/

//special symbols i added
terminal RSQBRACKET,LSQBRACKET,COLON;

// arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD, ASSIGN;
terminal LET, IN, LBRACE, RBRACE, COMMA;
terminal SEMI;

// arithmetic operators i created
terminal EXPO,BIN_INTEGER,HEX_INTEGER;
terminal PAIR;
terminal CAR;

// terminals with values
terminal Integer INTEGER;
terminal Double DOUBLE;
terminal String VARIABLE;
terminal String STR; // for strings encased in "" e.g "smpl"
terminal Boolean BOOL_TRUE;
terminal Boolean BOOL_FALSE;

/* Non terminals */
non terminal ArithProgram program;
non terminal StmtSequence stmtList;
non terminal Statement stmt;
non terminal StmtDefinition definition;

non terminal StmtLet letExp;
non terminal ArrayList<Binding> bindings;
non terminal ArrayList<Binding> bindingsAux;
non terminal Binding binding;

non terminal Exp expression;
non terminal Exp arithExp;
non terminal Exp term;
non terminal Exp factor;
non terminal FnPlotValue<?> number;
non terminal empty;

/* non terminals Jordan made */

non terminal Exp power;
non terminal PairFunction pair;
non terminal CarFunction car;

// non terminal StmtFun funExp;

/* Grammar rules */

program ::= stmtList:s {: RESULT = new ArithProgram(s); :};

stmtList ::= stmtList:lst stmt:s {:
		lst.add(s); 
		RESULT = lst;
		:} |
	     stmt:s {:
		RESULT = new StmtSequence(s);
		:};

stmt ::= definition:d {: RESULT = d; :} |
	 expression:e SEMI {: RESULT = e; :} ;

/*Britt Bratt*/
definition ::= DEF VARIABLE:v expression:e {: RESULT = new StmtDefinition(v, e); :};

helper ::= expression:e  {: RESULT = new StmtSequence(new StmtExpr(e)); :} | 
		   LBRACE stmtList:s RBRACE {: RESULT = s; :};

ifExp ::= IF expression:e THEN helper:s ELSE helper:s2 {: RESULT = new ExpIF(e, s, s2); :} |
		  IF expression:e THEN helper:s {: RESULT = new ExpIF(e, s); :};

concat ::= VARIABLE:v1 CONCAT VARIABLE:v2 {: RESULT = new ExpConcat(v1, v2); :};

readExp ::= READ LPAREN RPAREN {: RESULT = new IRExpRead(); :};

readIntExp ::= READINT LPAREN RPAREN {: RESULT = new ExpReadInt(); :};

/*logOp ::= comp:c1 AND comp:c2 {: RESULT = newExpLogAnd(a,b); :} |
		  comp:c1 OR comp:c2 {: RESULT = newExpLogOR(a,b); :} |
		  NOT comp:c1 {: RESULT = new ExpLogNOT(a,b); :};

comp ::= arithExp:exp1 COMPARE:sign arithExp:exp2 {: RESULT = new ExpComparison(sign, exp1, exp2); :} |
         arithExp:exp1 EQUAL arithExp:exp2 {: RESULT = new ExpComparison("=", exp1, exp2); :};	*/
/************************************************************************************************************/

car ::= CAR LPAREN pair:p RPAREN {:
		System.out.println("inside car");
		RESULT = new CarFunction( p);
:} |  CAR LPAREN VARIABLE:p RPAREN {:
		System.out.println("inside car");
		ExpVar var = new ExpVar(p);
		RESULT = new CarFunction(var);
:}; 

pair ::= PAIR LPAREN expression:e1 COMMA expression:e2 RPAREN {:
		ArrayList<Exp> store = new ArrayList<>();
		store.add(e1);
		store.add(e2);
		RESULT = new PairFunction("pair",store);
:};

expression ::=  letExp:l {: RESULT = l; :} |
		LBRACE stmtList:body RBRACE {: RESULT = body; :} |
		arithExp:a {: RESULT = a; :} | 
		pair:p {: RESULT = p; :} | 
		car:c {: RESULT = c; :} |
		//Britt
		concat:c {: RESULT = c; :} |
		ifExp:i {: RESULT = i; :} |
		readExp:e {: RESULT = e; :} |
		readIntExp:e {: RESULT = e; :};

/*Britt
condition ::= comp:c {RESULT = c; :} | 
			  logOp:l {RESULT = l; :};
*/
letExp ::= LET bindings:bs IN expression:body {:
			RESULT = new StmtLet(bs, body);
           :} ;

binding ::= VARIABLE:v ASSIGN expression:e {:
		RESULT = new Binding(v, e);
	    :};

bindings ::= binding:b bindingsAux:bl {:
		bl.add(0,b);
		RESULT = bl;
	     :} |
		empty {: RESULT = new ArrayList(); :};

bindingsAux ::= COMMA binding:b bindingsAux:bl {:
		  bl.add(0,b);
		  RESULT = bl;
		:} |
		empty {: RESULT = new ArrayList(); :};

definition ::= VARIABLE:v ASSIGN expression:e SEMI {:
		   RESULT = new StmtDefinition(v, e);
		:};

arithExp ::= arithExp:e PLUS term:t {:
			RESULT = new ExpAdd(e, t); :} |
		arithExp:e MINUS term:t {:
			RESULT = new ExpSub(e, t); :} |
		term:t {: RESULT = t; :} ;

power ::= factor:f EXPO power: p {: RESULT= new ExpExpo(f,p); :} |
						factor:f {: RESULT=f; :};

term ::= power:f MUL term:t {:
		RESULT = new ExpMul(f, t); :} |
	 power:f DIV term:t {:
		RESULT = new ExpDiv(f, t); :} |
	 power:f MOD term:t {:
		RESULT = new ExpMod(f, t); :} |
		power:p {: RESULT= p; :};


number ::= INTEGER:ilit {: RESULT = FnPlotValue.make( ilit ); :} | DOUBLE:ilit {: RESULT = FnPlotValue.make(ilit); :};

factor ::= number:n {: RESULT = new ExpLit( n ); :} |
	   VARIABLE:var {: RESULT = new ExpVar(var); :} |
	   LPAREN expression:e RPAREN {: RESULT = e; :};

empty ::= ;
